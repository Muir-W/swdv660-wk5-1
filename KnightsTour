# Author: Will Muir
# Date: 12/12/2020
# Description: This program solves a single knight's tour from any square on a standard 8x8 chess board
 
 
class ChessBoard():
    '''creates a chess board and holds all attributes and methods needed to solve a Knight's tour''' 

    def __init__(self, bSize):  # Creates a game board
        
        self._bSize = bSize                #board edge size (8)
        self.moveAccumulator = 0           #move tracker 1-64
        self._pattern = -1                 #what pattern the next move is currently in
        self._patternOrd = []              #search pattern sequence 
        
        #create bSize x bSize sized board filled with -1
        self._board = [[-1 for i in range(bSize)]for i in range(bSize)]  
        
        #holds possible for knight, eight possible moves
        self._posMoves = {0:[-2,1], 1:[-1,2], 2:[1,2], 3:[2,1], 4:[2, -1], 5:[1, -2], 6:[-1, -2], 7:[-2, -1]}
        
        #dictionary of coords in left diamond pattern
        self.leftDia = {1:[0,0], 11:[2,1], 18:[1,2], 28:[3,3], 5:[4,0], 15:[6,1], 22:[5,2], 32:[7,3], 33:[0,4],
                       43:[2,5], 50:[1,6], 60:[3,7], 37:[4,4], 47:[6,5], 54:[5,6], 64:[7,7]}
        
        #dictionary of coords in right diamond pattern
        self.rightDia = {4:[3,0], 10:[1,1], 19:[2,2], 25:[0,3], 8:[7,0], 14:[5,1], 23:[6,2], 29:[4,3], 36:[3,4],
                        42:[1,5], 51:[2,6], 57:[0,7], 40:[7,4], 46:[5,5], 55:[6,6], 61:[4,7]}
        
        #dictionary of coords in left square pattern
        self.leftSQ = {2:[1,0], 12:[3,1], 17:[0,2], 27:[2,3], 6:[5,0], 16:[7,1], 21:[4,2], 31:[6,3], 34:[1,4],
                      44:[3,5], 49:[0,6], 59:[2,7], 38:[5,4], 48:[7,5], 53:[4,6], 63:[6,7]}
        
        #dictionary of coords in right square pattern
        self.rightSQ = {9:[0,1], 3:[2,0], 20:[3,2], 26:[1,3], 13:[4,1], 7:[6,0], 24:[7,2], 30:[5,3], 35:[2,4],
                       41:[0,5], 52:[3,6], 58:[1,7], 39:[6,4], 45:[4,5], 56:[7,6], 62:[5,7]}
        
        
    #enter move count into the game board
    def enter_value(self, xCoord, yCoord, newValue, moveAdj):
        self._board[xCoord][yCoord] = newValue
        self.moveAccumulator = self.moveAccumulator + moveAdj
        
    #returns number from the board according to coords given 
    def get_value(self, xCoord, yCoord):
        return self._board[xCoord][yCoord]
    
    #prints out the values on the board
    def print_board(self):
        for x_coord in range(self._bSize):
            for y_coord in range(self._bSize):
                print("{0:=2d}".format(self._board[x_coord][y_coord]), end=' | ')
            print()
        return self._board
    
    #checks if coords are in a range between 0 and the max board edge
    def valid_move(self, xCoord, yCoord):
        if ((0 <= xCoord < self._bSize) and (0 <= yCoord < self._bSize)):
            return True
        else:
            return False
    
    #locates in what pattern a coord is located
    def find_1st_pattern(self, xCoord, yCoord):
        if [xCoord, yCoord] in self.leftDia.values():
            self._pattern = 0
            return 0
        elif [xCoord, yCoord] in self.leftSQ.values():
            self._pattern = 1
            return 1
        elif [xCoord, yCoord] in self.rightDia.values():
            self._pattern = 2
            return 2
        elif [xCoord, yCoord] in self.rightSQ.values():
            self._pattern = 3
            return 3
        else:
            self._pattern = -1
            return -1
    
    #verifies that the move is in the correct pattern
    def check_in_pattern(self, xCoord, yCoord, patID):
        
        if patID == 0 and [xCoord,yCoord] in self.leftDia.values():
            return True
        if patID == 1 and [xCoord,yCoord] in self.leftSQ.values():
            return True
        if patID == 2 and [xCoord,yCoord] in self.rightDia.values():
            return True
        if patID == 3 and [xCoord,yCoord] in self.rightSQ.values():
            return True
        else:
            return False
    
    #generator of the pattern sequence, creates sequence based on the starting position of the kights tour
    def patternOrd_gen(self, xCoord, yCoord):
        #determine the starting pattern
        firstPattern = self.find_1st_pattern(xCoord,yCoord)
            
        #determine the order to solve each of the four patterns
        template = [3,2,1,0]
        shift = -(1 + firstPattern)

        #shifts template sequence to begin with pattern of starting point
        for i in range(0,4):
            self._patternOrd.append(template[i+shift])
        return self._patternOrd
    
    #returns the resequenced search order
    def get_patternOrd(self):
        return self._patternOrd
        
   
def findSolution(brdSize):
    ''' Initiate finding solutions, initiates the tracing patterns and steps through each starting position on the board '''
    board_iteration = 0
    patOrder = []
    
    #nested for loops used to cycle through each starting point on the game board
    for x in range(brdSize):
        for y in range(brdSize):
            
            board_iteration += 1
            # Initialize Chess Board
            board = ChessBoard(brdSize)
            
            #determine the starting pattern
            patOrder = board.patternOrd_gen(x,y)
                           
            #knight starting position entered on the board as '1'
            board.enter_value(x,y,1,1)
            
            #knight's next move count
            move = 2
            
            #Start knight's tour on first pattern
            print("***** Board #:",board_iteration)
            print()
            if(not tracePattern(brdSize, board, x, y, move, patOrder[0])):   #first call to tracePattern; begin finding solutions
                print("Failed to find Knight's tour")

            else:
                board.print_board() #if solution is found, print out the complete board
            print()
 
 
def tracePattern(brdSize, board, x, y, move, patternID):
    ''' Recursively find knight's tour solutions '''
 
    #Base Case; check if all spaces on chess board have been used
    if(move == (brdSize*brdSize)+1):            
        return True
    
    else:
        
        patOrder = board.get_patternOrd()
        if move>1:
            patternID = patOrder[((move-1)//16)]
         
        # Try all next moves from the current coordinate x, y
        for i in range(8):
            new_x = x + (board._posMoves[i])[0]
            new_y = y + (board._posMoves[i])[1]

            #check that current move has met criteria before entering the move count on the board
            if (board.valid_move(new_x, new_y) and board.get_value(new_x,new_y) == -1 and board.check_in_pattern(new_x,new_y,patternID)):
                board.enter_value(new_x,new_y,move,1)
        
                if(tracePattern(brdSize, board, new_x, new_y, move+1, patternID)):
                    return True
 
                # Reset x,y value to unused if move failed
                board.enter_value(new_x,new_y,-1,-1)
                
        #return False if all 8 possible moves are tried and no acceptible outcomes are found from current move;
        #go back to previous move position and try next possible move. Continue cycle until criteria is met to
        #enter value on the board
        return False 
 
#main main function
def main():
    
    boardEdgeSize = 8 #standard edge size for chess board
    findSolution(boardEdgeSize) #call function to solve 1 Knight's tour from each chess board square
 
main()
